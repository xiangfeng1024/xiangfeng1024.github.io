<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>笔记3：深入剖析xPortPendSVHandler切换过程</title>
    <link href="/2024/08/30/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%87%BD%E6%95%B0xPortPendSVHandler%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%EF%BC%88%E9%80%90%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2024/08/30/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%87%BD%E6%95%B0xPortPendSVHandler%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%EF%BC%88%E9%80%90%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h1><p>本人近段时间在分析和研读FreeRTOS内核的源码，分析到<code>xPortPendSVHandler</code>任务切换函数的时候查了一下网上的资料，很多很全，但是没有一个非常深入、详细、易懂的教程，这里记录一下我自己的理解。有错误的地方还请指正，可以在评论区一起讨论。</p><p><strong>学习内核的源码，能让人读懂、能理解的讲述才是最好的</strong>，本篇文章只详细介绍<code>xPortPendSVHandler</code>这一个函数的机制和原理，选用的FreeRTOS移植的是<code>ARM-Cortex-M4F</code>的内核，内容与M3基本一致，可以一同分析。要理解<code>xPortPendSVHandler</code>的底层原理还需要用的其他的一些基础知识，这里都已罗列，但是不会细讲，需要有一定的ARM开发基础。</p><h1 id="二、分析源码的前提"><a href="#二、分析源码的前提" class="headerlink" title="二、分析源码的前提"></a>二、分析源码的前提</h1><h4 id="1-ARM内核寄存器的理解"><a href="#1-ARM内核寄存器的理解" class="headerlink" title="1.ARM内核寄存器的理解"></a>1.ARM内核寄存器的理解</h4><p><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/1.png" alt="ARM-Cortex-M4F内核的一部分寄存器"></p><ul><li>ARM内核中有上图所示这些寄存器。</li><li>R0-R12都可以用来保存中间的计算结果。</li><li>&#x3D;&#x3D;R13比较关键&#x3D;&#x3D;，R13是堆栈指针，MSP是主堆栈指针，PSP是进程堆栈指针，<font color= #AA0000 face="黑体" size=4><strong>两个指针可以通过指令来切换使用，两个指针的值可以不一样，可以自己设置</strong></font>，了解这个即可。</li><li>R14是链接寄存器LR，保存函数的返回地址。<font color= #AA0000 face="黑体" size=4><strong>函数跳转硬件自动保存PC的下一条指令地址到LR</strong></font></li><li>R15是程序计数器PC，PC里面的当前值一般指向正在执行指令地址+4处，<font color= #AA0000 face="黑体" size=4><strong>PC指向哪里，CPU就运行哪条代码</strong></font>，了解这个即可。</li></ul><p><strong><font color= #AAAA00 face="黑体" size=5>ARM内核中的寄存器的值就表示当前CPU运行的状态，我们称为“现场”，了解以上知识我们就可以进行下一步准备。</strong> </font></p><h4 id="2-栈的理解"><a href="#2-栈的理解" class="headerlink" title="2.栈的理解"></a>2.栈的理解</h4><ul><li>栈是一种数据结构，在MCU中，它是&#x3D;&#x3D;一段位于RAM的内存空间&#x3D;&#x3D;。我们只需要知道：<font color= #AA0000 face="黑体" size=4><strong>栈按照先进后出的原则，栈向下增长（从栈顶指针处地址开始递减）</strong></font>就OK。</li><li>push是入栈，将SP指针减一，再填入某个数据（注意32位MCU中指针操作+1都是当前地址+0x00000004）</li><li>pop是出栈，去除某个数据存到某个寄存器，再将SP+1</li><li><font color= #AA0000 face="黑体" size=4><strong>栈一般是用来保存函数即将跳转时当前函数内的寄存器状态</strong></font><br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/2.jpeg" alt="MCU栈的图例"><br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/3.jpeg"><br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/4.jpeg"></li></ul><h4 id="3-分析pxPortInitialiseStack函数"><a href="#3-分析pxPortInitialiseStack函数" class="headerlink" title="3.分析pxPortInitialiseStack函数"></a>3.分析pxPortInitialiseStack函数</h4><p>为什么要了解这个函数？因为这个函数初始化了任务的堆栈，每个任务在被创建的时候都会通过该函数初始化堆栈，每个任务都有自己的堆栈，这个堆栈就称为任务运行时的“现场”，切换任务，当然就是切换现场，所以这个函数对于理解任务切换机制非常有用。<code>（如果已自行了解该函数可以跳过此分析）</code><br><code>pxPortInitialiseStack</code>函数源码如下：（已将注释翻译成中文）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * See header file for description.</span><br><span class="hljs-comment"> */</span><br>StackType_t * <span class="hljs-title function_">pxPortInitialiseStack</span><span class="hljs-params">( StackType_t * pxTopOfStack,</span><br><span class="hljs-params">                                     TaskFunction_t pxCode,</span><br><span class="hljs-params">                                     <span class="hljs-type">void</span> * pvParameters )</span><br>&#123;<br>    <span class="hljs-comment">/* Simulate the stack frame as it would be created by a context switch</span><br><span class="hljs-comment">     * interrupt. */</span><br>    <span class="hljs-comment">/* 模拟上下文切换中断时创建的栈帧,俗称“伪造现场” */</span><br>    <span class="hljs-comment">/*  */</span><br><br>    <span class="hljs-comment">/* Offset added to account for the way the MCU uses the stack on entry/exit</span><br><span class="hljs-comment">     * of interrupts, and to ensure alignment. */</span><br>    <span class="hljs-comment">/* 偏移量被添加以适应微控制器在进入/退出中断时使用栈的方式，并确保对齐 */</span><br>    pxTopOfStack--;<br><br>    *pxTopOfStack = portINITIAL_XPSR;                                    <span class="hljs-comment">/* xPSR */</span><br>    pxTopOfStack--;<br>    *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; <span class="hljs-comment">/* PC */</span><br>    pxTopOfStack--;<br>    *pxTopOfStack = ( StackType_t ) prvTaskExitError;                    <span class="hljs-comment">/* LR */</span><br><br>    <span class="hljs-comment">/* Save code space by skipping register initialisation. */</span><br>    <span class="hljs-comment">/* 跳过寄存器初始化以节省代码空间 */</span><br>    pxTopOfStack -= <span class="hljs-number">5</span>;                            <span class="hljs-comment">/* R12, R3, R2 and R1. */</span><br>    *pxTopOfStack = ( StackType_t ) pvParameters; <span class="hljs-comment">/* R0 */</span><br><br>    <span class="hljs-comment">/* A save method is being used that requires each task to maintain its</span><br><span class="hljs-comment">     * own exec return value. */</span><br>    <span class="hljs-comment">/* 正在使用一种保存方法，该方法要求每个任务维护自己的exec返回值 ARM内核知识，LR保存值为0XFFFFFFFD表示返回之后使用PSP*/</span><br><br>    pxTopOfStack--;<br>    *pxTopOfStack = portINITIAL_EXC_RETURN;<br><br>    pxTopOfStack -= <span class="hljs-number">8</span>; <span class="hljs-comment">/* R11, R10, R9, R8, R7, R6, R5 and R4. */</span><br><br>    <span class="hljs-keyword">return</span> pxTopOfStack;<br>&#125;<br><span class="hljs-comment">/*-----------------------------------------------------------*/</span><br></code></pre></td></tr></table></figure><p>这里放VScode图片内容更醒目。<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/5.jpeg" alt="源码"><br>光看这一个函数可能看的很迷糊，不急，我们一步步分析。</p><h5 id="（1）参数1：StackType-t-pxTopOfStack"><a href="#（1）参数1：StackType-t-pxTopOfStack" class="headerlink" title="（1）参数1：StackType_t * pxTopOfStack"></a>（1）参数1：StackType_t * pxTopOfStack</h5><ul><li>首先分析函数的第一个传入参数<code>StackType_t * pxTopOfStack</code>，栈顶指针。分析他的调用关系，他是被传入的什么值，具体分析如下：</li><li>在task.c文件第1006行（大概），被<code>prvInitialiseNewTask</code>函数调用，传入值为<code>pxTopOfStack</code><br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/6.jpeg"></li><li><code>pxTopOfStack</code>的赋值在前面，第857行，如图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/7.jpeg" alt=" "></li><li><ul><li>857行赋值这个指针使其等于要新创建任务的TCB结构体中栈数组首地址，这个首地址是什么？我们还要去了解这个数组是在哪里被分配的。</li></ul></li><li><ul><li>在task.c文件第801行，被<code>xTaskCreate</code>函数调用，他的第7个参数就是<code>pxNewTCB</code>，如下图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/8.jpeg" alt=" "></li></ul></li><li><ul><li>然后我们需要知道在哪里<code>pxNewTCB-&gt;pxStack</code>该值被分配，继续往前找，在第763行的这一块。如下图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/9.jpeg" alt=" "></li></ul></li><li><ul><li><code>pvPortMallocStack</code>就是分配该任务堆栈空间的函数，得到的首地址赋值给了<code>pxStack</code>，然后紧接着在后面就把<code>pxStack</code>赋值给了<code>pxNewTCB-&gt;pxStack</code>，至此，我们找到了<code>pxNewTCB-&gt;pxStack</code>的来源。</li></ul></li></ul><p>回到下面这张图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/10.jpeg" alt=" "></p><ul><li>第一句我们分析完了，通过<code>malloc</code>分配了指定栈大小的空间到该TCB结构体的<code>pxStack</code>中，然后获取这个地址值给到<code>pxTopOfStack</code>变量作为新创建任务的栈顶指针</li><li>第二句是使一个地址按8字节方式对齐，如果<code>malloc</code>申请的内存首地址不能被8字节整除，那就要对他进行偏移，舍弃一部分空间不使用，使这块内存首地址进行8字节对齐。至于为什么要进行字节对齐，那得自行去了解操作系统和ARM内核了，这里不细讲。</li><li>至此第一个参数<code>StackType_t * pxTopOfStack</code>就分析完了，总结：他表示这个新创建任务的栈顶指针。</li></ul><h5 id="（2）参数2：TaskFunction-t-pxCode"><a href="#（2）参数2：TaskFunction-t-pxCode" class="headerlink" title="（2）参数2：TaskFunction_t pxCode"></a>（2）参数2：TaskFunction_t pxCode</h5><ul><li>很明显，他就是我们要执行的任务函数的函数入口指针。</li><li>我们观察他的作用，如下图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/11.jpeg" alt=" "></li><li>可以看到通过注释我们知道他最终被保存进了PC寄存器，中间过程我们等会再分析。</li><li>前面讲过<font color=  #AA0000 face="黑体" size=4><strong>PC指向哪里，CPU就运行哪条代码</strong></font>，看到这里我们就可以猜测到任务切换时的操作就是通过这种方式实现的（&#x3D;&#x3D;确实是的&#x3D;&#x3D;），&#x3D;&#x3D;直接改变PC的值，使其等于某个任务的任务运行函数入口指针&#x3D;&#x3D;，后面的&amp;上某个宏定义是有关ARM内核指令集的内容，这里不介绍。</li></ul><h5 id="（3）参数3：void-pvParameters"><a href="#（3）参数3：void-pvParameters" class="headerlink" title="（3）参数3：void * pvParameters"></a>（3）参数3：void * pvParameters</h5><ul><li>作用位置如下图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/12.jpeg" alt=" "></li><li><code>void * pvParameters</code>最终被保存进R0寄存器，这里直接告诉大家答案，这个是为了给任务函数传递用户自定义参数用的，在ARM的指令集规范里面，R0-R3一般用来传递函数的参数。</li></ul><h5 id="（4）过程分析"><a href="#（4）过程分析" class="headerlink" title="（4）过程分析"></a>（4）过程分析</h5><ul><li>参数分析完毕，现在进行过程分析。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Offset added to account for the way the MCU uses the stack on entry/exit</span><br><span class="hljs-comment"> * of interrupts, and to ensure alignment. */</span><br><span class="hljs-comment">/* 偏移量被添加以适应微控制器在进入/退出中断时使用栈的方式，并确保对齐 */</span><br>pxTopOfStack--;<br><br>*pxTopOfStack = portINITIAL_XPSR;                                    <span class="hljs-comment">/* xPSR */</span><br></code></pre></td></tr></table></figure><ul><li>首先<code>栈顶指针--</code>，然后再填入数据<code>portINITIAL_XPSR</code>，就是我上边介绍栈时的<code>push</code>操作，（<code>指针--</code>操作默认是减去4字节，后文不重复解释），假设栈大小还是100字节，栈顶指针0x20000100，此时新任务堆栈结构如下图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/13.jpeg" alt=" "></li><li>下一步继续<code>push</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">pxTopOfStack--;<br>*pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; <span class="hljs-comment">/* PC */</span><br>pxTopOfStack--;<br>*pxTopOfStack = ( StackType_t ) prvTaskExitError;                    <span class="hljs-comment">/* LR */</span><br></code></pre></td></tr></table></figure><ul><li>栈：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/14.jpeg" alt=" "></li><li>后面的步骤就是连续<code>push</code>操作，这里就不逐步分析了，直接根据注释，给出该函数执行完成后的栈分配图。<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/15.jpeg" alt=" "></li><li>根据函数内容和前面的分析，应该大家都能推出这张图了。（为什么空缺的都是0XA5?其实在前面我们通过<code>memset</code>将所有栈空间内存全部覆写为0XA5了，不过这对我们的分析不重要，可以跳过）。</li><li>实在还是不太理解中间的过程也没关系，先记着这张图，后面还会再提到，分析这个函数，只要知道最后这张图即可，<font color=  #AA0000 face="黑体" size=4><strong>最后这张图是核心！</strong></font></li></ul><h5 id="（5）pxPortInitialiseStack调用过程"><a href="#（5）pxPortInitialiseStack调用过程" class="headerlink" title="（5）pxPortInitialiseStack调用过程"></a>（5）pxPortInitialiseStack调用过程</h5><ul><li>通过前面的分析大家也可以找到<code>pxPortInitialiseStack</code>函数是被<code>xTaskCreate</code>函数调用的。而这个<code>xTaskCreate</code>就是我们最常见的动态创建任务API了，层级调用关系如图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/16.jpeg" alt=" "></li><li>通过层级调用关系我们就知道：&#x3D;&#x3D;我们每创建一个新任务都会在创建的时候为他分配好堆栈空间，并且初始化好前面提到的栈空间图的数据&#x3D;&#x3D;，堆栈的起始地址由<code>malloc</code>自动分配，大小由用户决定，在<code>xTaskCreate</code>的时候需要指定堆栈大小，每个任务由自己的<code>TCB</code>结构体，栈顶指针放在该结构体中。</li><li>假如我们在程序中创建了<code>Task1</code>、<code>Task2</code>、<code>Task3</code>这三个任务，初始化堆栈大小都是100字节，那么在<code>MCU</code>的<code>RAM</code>中，就会有以下三个块：(引用的前图，实际地址大家不用关系)<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/17.jpeg" alt=" "></li><li>至此，<code>pxPortInitialiseStack</code>分析就完成了。</li><li>结论：<code>pxPortInitialiseStack</code>按照下图给每个创建的任务栈顶处填充了数据。<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/18.jpeg" alt=" "></li></ul><h4 id="4-MSP和PSP的切换"><a href="#4-MSP和PSP的切换" class="headerlink" title="4.MSP和PSP的切换"></a>4.MSP和PSP的切换</h4><p>任何中断和异常中都使用<code>MSP</code>主栈顶指针，什么意思，就是在中断中的程序都使用<code>MSP</code>里面保存的值作为当前<code>SP</code>（<code>R13</code>寄存器）的值。</p><p>在FreeRTOS中，从<code>MSP</code>切换到<code>PSP</code>使用的方法是：</p><ul><li><p>1.先将中断返回特殊值<code>portINITIAL_EXC_RETURN(0xfffffffd)</code>保存至任务堆栈中。<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/19.jpeg" alt=" "></p></li><li><p>2.再将任务控制块的栈顶指针<code>pxCurrentTCB</code>(因为在TCB结构体中，栈顶指针放在首位，所以结构体首地址就是栈顶指针)保存至<code>PSP</code>中。<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/20.jpeg" alt=" "></p></li><li><p>3.<code>pop</code>出栈，将特殊值<code>portINITIAL_EXC_RETURN</code>从栈中弹出至<code>R14（LR寄存器）</code>中，在<code>SVC</code>中断中，如果返回地址是特殊值<code>portINITIAL_EXC_RETURN</code>的话返回之后程序将使用<code>PSP</code>指针（ARM内核规定），如下图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/21.jpeg" alt=" "><br><code>SVC</code>中断中<code>POP</code>指令如下图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/22.jpeg" alt=" "><br>ARM内核的中断有规定，程序在进入中断之前使用哪个堆栈指针，那么程序退出中断时就会使用哪个堆栈指针，而FreeRTOS是使用中断来切换任务，所以从切换完第一次堆栈指针之后，&#x3D;&#x3D;所有任务都使用<code>PSP</code>指针，而中断都自动使用<code>MSP</code>指针&#x3D;&#x3D;，这就是FreeRTOS中使用的双堆栈机制，这个机制有什么用？后面分析会用到。</p></li></ul><h1 id="三、开始逐行分析xPortPendSVHandler"><a href="#三、开始逐行分析xPortPendSVHandler" class="headerlink" title="三、开始逐行分析xPortPendSVHandler"></a>三、开始逐行分析xPortPendSVHandler</h1><h4 id="1-xPortPendSVHandler执行的前文"><a href="#1-xPortPendSVHandler执行的前文" class="headerlink" title="1.xPortPendSVHandler执行的前文"></a>1.xPortPendSVHandler执行的前文</h4><p>首先得知道一点：<code>xPortPendSVHandler</code>是在滴答定时器中断里面被调用，被调用的情况是系统发生了任务调度，要从上一个任务切换到下一个要运行的目标任务。<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/23.jpeg" alt=" "><br>我们假设以下的情景如下图：<br><strong>后续任务1都会被认为是被切换的任务，任务2都是被切换后的目标任务。</strong><br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/24.jpeg" alt=" "></p><h4 id="2-xPortPendSVHandler源码（M4F内核版本）"><a href="#2-xPortPendSVHandler源码（M4F内核版本）" class="headerlink" title="2.xPortPendSVHandler源码（M4F内核版本）"></a>2.xPortPendSVHandler源码（M4F内核版本）</h4><p>源码如下：(注释已翻译)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">xPortPendSVHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-keyword">extern</span> uxCriticalNesting;<br>    <span class="hljs-keyword">extern</span> pxCurrentTCB;<br>    <span class="hljs-keyword">extern</span> vTaskSwitchContext;<br><br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8<br><br>    mrs r0, psp<br>    isb<br>    <span class="hljs-comment">/* Get the location of the current TCB. */</span><br>    <span class="hljs-comment">/* 获取当前TCB的位置 */</span><br>    ldr r3, =pxCurrentTCB<br>    ldr r2, [ r3 ]<br><br>    <span class="hljs-comment">/* Is the task using the FPU context?  If so, push high vfp registers. */</span><br>    <span class="hljs-comment">/* 任务是否使用FPU上下文？如果是，则保存vfp寄存器 */</span><br>    tst r14, #<span class="hljs-number">0x10</span><br>    it eq<br>    vstmdbeq r0!, &#123;s16-s31&#125;<br><br>    <span class="hljs-comment">/* Save the core registers. */</span><br>    <span class="hljs-comment">/* 保存核心寄存器. */</span><br>    stmdb r0!, &#123;r4-r11, r14&#125;<br><br>    <span class="hljs-comment">/* Save the new top of stack into the first member of the TCB. */</span><br>    <span class="hljs-comment">/* 将新的栈顶保存到TCB的第一个成员中。 */</span><br>    str r0, [ r2 ]<br><br>    stmdb sp!, &#123;r0, r3&#125;<br>    mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY<br>    msr basepri, r0<br>    dsb<br>    isb<br>    bl vTaskSwitchContext<br>    mov r0, #<span class="hljs-number">0</span><br>    msr basepri, r0<br>    ldmia sp!, &#123;r0, r3&#125;<br><br>    <span class="hljs-comment">/* The first item in pxCurrentTCB is the task top of stack. */</span><br>    <span class="hljs-comment">/* pxCurrentTCB中的第一项是堆栈的任务顶部 */</span><br>    ldr r1, [ r3 ]<br>    ldr r0, [ r1 ]<br><br>    <span class="hljs-comment">/* Pop the core registers. */</span><br>    <span class="hljs-comment">/* 弹出核心寄存器 */</span><br>    ldmia r0!, &#123;r4-r11, r14&#125;<br><br>    <span class="hljs-comment">/* Is the task using the FPU context?  If so, pop the high vfp registers</span><br><span class="hljs-comment">     * too. */</span><br>    <span class="hljs-comment">/* 任务是否使用FPU上下文？如果是，则弹出vfp寄存器 */</span><br>    tst r14, #<span class="hljs-number">0x10</span><br>    it eq<br>    vldmiaeq r0!, &#123;s16-s31&#125;<br><br>    msr psp, r0<br>    isb<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WORKAROUND_PMU_CM001 <span class="hljs-comment">/* XMC4000 specific errata */</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> WORKAROUND_PMU_CM001 == 1</span><br>            push &#123; r14 &#125;<br>            pop &#123; pc &#125;<br>            nop<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    bx r14<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-第一部分——保存现场"><a href="#3-第一部分——保存现场" class="headerlink" title="3.第一部分——保存现场"></a>3.第一部分——保存现场</h4><p><code>PRESERVE8</code><br>表示从C代码进入汇编代码的世界时，要保证汇编部分的编码在调用c接口时栈是8字节对齐的。<br>*——————————————————</p><p><code>mrs r0, psp</code><br><code>mrs</code>指令可以操作特殊功能寄存器，他的功能与<code>ldr</code>指令一致，只是权限更高，可以访问特殊功能寄存器。这里用它访问<code>psp</code>寄存器，把<code>psp</code>值读出并存放到<code>r0</code>。通过阅读源码可知，此时<code>psp</code>的值就是<code>pxCurrentTCB</code>当前运行任务的栈顶指针值，如下图所示位置被修改：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/25.jpeg" alt=" "><br>（<code>SVC</code>这里不进行分析，但这里补充一点<code>SVC中断</code>的知识：<code>SVC中断</code><strong>只在任务开始调度时运行一次</strong>，在<code>SVC</code>中<code>psp</code>被赋值为当前任务的栈顶指针是为了开始第一个任务的运行，后续<code>SVC</code>不会再次被触发，所以<code>psp</code>指针其实<font color=  #AA0000 face="黑体" size=4><strong>每次就是指向了当前任务的栈顶</strong></font>)。</p><p><code>xPortPendSVHandler</code>在前半部分很明显是为了<font color=  #AA0000 face="黑体" size=4><strong>保存现场</strong></font>， 这条指令很好的体现了双堆栈指针的好处，在这里就可以直接取出<code>psp</code>的值作为&#x3D;&#x3D;任务1&#x3D;&#x3D;的栈顶指针，<font color=  #AA0000 face="黑体" size=4><strong>而不再需要逐步往前推<code>SP</code>寄存器的值才能得到前一个任务的栈顶指针</strong></font>。因为此时是中断状态，<code>CPU</code>是使用<code>MSP</code>指针，不会因为中断而在任务的堆栈上保存相关信息。<br>*——————————————————</p><p><code>isb</code><br>指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执<br>行完毕之后，才执行它后面的指令。（ARM内核知识，不需要理解，有兴趣的可以去了解ARM-Cortex-M3内核取指令时的流水线机制）<br>*——————————————————</p><p><code>ldr r3, =pxCurrentTCB</code><br><code>ldr</code>指令，没啥好讲的，就是把后一个值读出并存放到<code>，</code>前面的寄存器，但这里是用了特殊的用法，使用的是伪指令，功能就是将&#x3D;&#x3D;任务1&#x3D;&#x3D;的<code>TCB</code>结构体指针的&#x3D;&#x3D;地址&#x3D;&#x3D;写入<code>r3</code>（因为<code>ldr</code>只能存放符合规范的32位立即数或值，TCB的地址值可能是不合规范的32位值，这里使用伪指令就能这样操作）。<br>*——————————————————</p><p><code>ldr r2, [ r3 ]</code><br>读出<code>r3</code>指向的地址的值并存放<code>r2</code>（等价<code>r2 = (*r3)</code>），得到任务1<code>TCB</code>结构体的首地址并存放到<code>r2</code>。<br>*——————————————————</p><p><code>tst r14, #0x10</code><br><code>it eq</code><br><code>vstmdbeq r0!, &#123;s16-s31&#125;</code><br>这三条是保存当前浮点寄存器的值至浮点寄存器（<code>Cortex-M4F</code>内核才有的，M3内核代码中没有该三句），M3内核可以不用关心，这三句不重要。<br>*——————————————————</p><p><code>stmdb r0!, &#123;r4-r11, r14&#125;</code><br>这条指令就是比较核心的<code>push</code>入栈操作了，以<code>r0</code>为基地址。开始把<code>r4</code>寄存器中地址指向的内容读出并放入<code>r0</code>寄存器中地址指向的内容，然后<code>r0</code>向下增长一个地址（4字节），然后再把<code>r5</code>所指内容放入<code>r0</code>……………依此类推。</p><p><code>r0</code>在这里是<code>psp</code>的值，也就是保存当前CPU内<code>r4-r11</code>还有<code>r14(LR)</code>的值到栈中。目前的栈如下图：（注意这里<code>r0</code>只是引用了<code>psp</code>的值而未改变<code>psp</code>，所以只是栈变化，<code>psp</code>未变化）<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/26.jpeg" alt=" "><br>*——————————————————</p><p><code>str r0, [ r2 ]</code><br><code>str</code>指令就是<code>ldr</code>指令的反义，他将<code>r0</code>的值写入<code>r2</code>所指的地址。从上图我们可以指定<code>r0</code>目前的值就是任务1当前栈空间的&#x3D;&#x3D;栈顶指针&#x3D;&#x3D;，而<code>r2</code>所指位置就是任务1的TCB结构体里面存储的栈顶指针的值。<font color=  #AA0000 face="黑体" size=4><strong>这一步就是将保存的现场（现场就是CPU各寄存器的值）存储覆写到自己的TCB结构体中保存的栈顶指针值，更新栈顶指针。</strong></font></p><p>我们可以看到，我们在这里只保存了部分寄存器，还有一部分寄存器怎么没有保存？比如<code>r0,r1,r2</code>这些。这是因为ARM内核在程序进入<code>PendSV中断</code>中硬件会自动保存<code>r0、r1、r2、r3、PSR、PC、LR</code>寄存器，我们能看到的保存都是软件保存，他们存放的位置就是位于上图浮点寄存器空间的上方。<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/27.jpeg" alt=" "><br><strong>至此，CPU所有寄存器都已入栈，保存了现场之后的栈顶指针也都更新到了当前任务（这里是任务1）的TCB中。</strong></p><p>我们再看看前面画的这张图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/28.jpeg" alt=" "><br>是不是在<code>PendSV中断</code>进入到这一步时，所有的任务的栈空间都回到了这种状态？（只是红色箭头指的不一定是最上面那块内存，可能因为任务运行导致使用了栈空间而下移）是不是跟前面的串通了？<br>*——————————————————</p><h4 id="4-第二部分——选出最高优先级任务，更新pxCurrentTCB"><a href="#4-第二部分——选出最高优先级任务，更新pxCurrentTCB" class="headerlink" title="4.第二部分——选出最高优先级任务，更新pxCurrentTCB"></a>4.第二部分——选出最高优先级任务，更新pxCurrentTCB</h4><p><code>stmdb sp!, &#123;r0, r3&#125;</code><br>这条指令会与后面的指令<code>ldmia sp!, &#123;r0, r3&#125;</code>对应，一同分析。<br>先明确，这里的<code>sp</code>是在操作<code>msp</code>所指位置，因为这是在中断中。所以这条指令不会干涉到<code>psp</code>的入栈和出栈。这条指令前面已经介绍过，就是&#x3D;&#x3D;依次入栈&#x3D;&#x3D;。这是为了后续要进入函数跳转，也需要保存现场而做的准备，将<code>r0、r3</code>入栈，等到函数执行完成，在<code>r0、r3</code>出栈，恢复到CPU内。<br>*——————————————————</p><p><code>mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY</code><br><code>mov</code>指令是数据传输指令，这里用法很简单，就是把后面这个宏定义的立即数存放到<code>r0</code>寄存器。<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code>的值如下图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/29.jpeg" alt=" "><br>定义了内核可屏蔽的最高优先级。为后续关中断做准备。<br>*——————————————————</p><p><code>msr basepri, r0</code><br>使用<code>msr</code>指令操作特权寄存器<code>basepri</code>，目的是屏蔽某一个优先级及其以下优先级的中断（<strong>关中断</strong>），防止后续找出最高优先级的过程中被其它中断打断。<br>*——————————————————<br><code>dsb</code><br><code>isb</code><br>数据和指令同步</p><p>*——————————————————<br><code>bl vTaskSwitchContext</code><br><code>bl</code>是程序跳转指令，跳转到一个地址去执行程序并将此时的返回地址保存至<code>LR</code>寄存器。<code>vTaskSwitchContext</code>这是个C函数，他的作用是找出当前就绪态链表中最高优先级的任务，并将当前任务控制块<code>pxCurrentTCB</code>的值更新为这个任务的TCB。（就是我们说的任务切换了，当前任务从任务1切换至任务2）。<br>我们这里只关心任务如何切换，这里有关的内容就是<code>pxCurrentTCB</code>的值被更新，至于如何找到最高优先级的任务，可以看最后的补充内容。</p><p>*——————————————————<br><code>mov r0, #0</code><br><code>msr basepri, r0</code><br>这两句一起讲，与前面的关中断对应，这里就是开中断，<code>basepri</code>写入0就是不屏蔽任何中断。</p><p><code>ldmia sp!, &#123;r0, r3&#125;</code>也在前面已经被分析过了。</p><p>*——————————————————</p><h4 id="5-第三部分——恢复现场"><a href="#5-第三部分——恢复现场" class="headerlink" title="5.第三部分——恢复现场"></a>5.第三部分——恢复现场</h4><p><code>ldr r1, [ r3 ]</code><br>这里的<code>r3</code>可以从前面的程序知道，保存的是<code>pxCurrentTCB</code>的地址，访问这个地址就可以得到任务2的TCB首地址（这里<code>pxCurrentTCB</code>已经被更新为任务2了）。存放在<code>r1</code>寄存器中。<br>*——————————————————</p><p><code>ldr r0, [ r1 ]</code><br>读出<code>r1</code>寄存器地址所指数据存放到<code>r0</code>，就是读出任务2的栈顶指针。因为在TCB中，TCB结构体首地址存放的数据是从栈顶指针开始。<br>*——————————————————</p><p><code>ldmia r0!, &#123;r4-r11, r14&#125;</code><br>开始出栈，与<code>stmdb r0!, &#123;r4-r11, r14&#125;</code>是对应的，不用过多分析，就是将任务2的栈空间按照顺序，将内容逐个移至CPU寄存器中，实现<font color=  #AA0000 face="黑体" size=4><strong>恢复现场</strong></font>。</p><p>任务2在被调度时，也会像刚刚任务1那样，先被保存了现场，因此任务2在被恢复现场时可以参考上面的栈空间图片，他们都是一样的。</p><p><strong>如果任务2是第一次被恢复，那么也需要一个栈，这个栈就联系起来了我们为什么要去分析<code>pxPortInitialiseStack</code>函数了，该函数在任务2还没有被保存现场时就构造了一个现场，函数列出了栈中所有寄存器的值。</strong><br>*——————————————————</p><p><code>tst r14, #0x10</code><br><code>it eq</code><br><code>vldmiaeq r0!, &#123;s16-s31&#125;</code><br>恢复浮点寄存器的值<br>*——————————————————</p><p><code>msr psp, r0</code><br>这一步也很关键，我们知道前面<code>r0</code>在恢复完所有的寄存器之后，就回到了原来的栈顶。因为每个任务的栈空间都是独立分配的，他们不一定连续，所以就要不断修改<code>psp</code>的值，因为<code>psp</code>是一定要指向当前程序的栈顶的，所以在恢复完现场之后，栈顶也要恢复。<br>*——————————————————</p><p><code>isb</code><br>指令同步<br>*——————————————————</p><h4 id="6-第四部分——任务栈恢复分析"><a href="#6-第四部分——任务栈恢复分析" class="headerlink" title="6.第四部分——任务栈恢复分析"></a>6.第四部分——任务栈恢复分析</h4><p><code>bx r14</code><br>bx跳转指令，目标地址处的指令既可以是ARM 指令，也可以是Thumb指令。<br>注意这里是跳转到<code>r14</code>，我们要分析此时CPU的<code>r14</code>存放的是什么内容。分两种情况。</p><ul><li><p>情况一：任务2不是第一次被调度<br>这种情况下，是属于任务2在运行过程中被<code>SysTick中断</code>打断，那么在打断的同时硬件就保存了程序要运行的下一条指令作为返回地址存放至<code>r14</code>，此时在执行这条指令时程序就原封不动的回到任务2被打断之前的地方继续执行任务。</p></li><li><p>情况2：任务2是第一次被调度<br>这种情况下，任务2的栈是被程序构造的，他的<code>r14</code>寄存器存放的是一个特殊值<code>portINITIAL_EXC_RETURN</code>，如下图：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/30.jpeg" alt=" "><br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/31.jpeg" alt=" "><br>这里为什么把这个位置称为（LR(特殊)）呢？我们进行分析。任务被创建时，就构造了这么一个现场，在第一次被恢复时，是使用<code>ldmia r0!, &#123;r4-r11, r14&#125;</code>这条指令，没错，在（R11）上方这个位置，被我们软件恢复至<code>r14(LR)</code>寄存器。<br>又因为任务2是第一次被调用，不会有硬件帮我们保存上半部分那些寄存器，所以FreeRTOS用软件的方式保存了那些寄存器，并设置<code>LR</code>为特殊值<code>0xfffffffd</code>，使得程序在<code>bx r14</code>时，被当做一个中断返回处理，返回之后程序使用<code>psp</code>的值作为<code>sp</code>栈顶指针，并自动将上半部分的所有寄存器自动出栈恢复至CPU内。<br>我们知道，<code>pc</code>寄存器的值就是程序要执行的指令的地方，上边部分的值被恢复，上图<code>pc</code>的值同样被恢复了，而<code>pc</code>的值被设置为任务2的回调函数入口地址，所以从下一个指令开始，程序就会运行任务2了。<br>至此，任务2切换完成。</p></li></ul><p>*——————————————————<br>至此，<code>xPortPendSVHandler</code>分析完成。</p><h1 id="四、补充内容"><a href="#四、补充内容" class="headerlink" title="四、补充内容"></a>四、补充内容</h1><p><code>vTaskSwitchContext</code>是找出就绪态链表最高优先级的函数，这个函数就是FreeRTOS的调度算法，最核心内容。<br>他的内部实现是通过<code>taskSELECT_HIGHEST_PRIORITY_TASK</code>来实现<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/32.jpeg" alt=" "><br>宏定义主体：<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/33.jpeg" alt=" "></p><p>箭头指的就是他的调度算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 31UL - ( uint32_t ) __clz( ( uxReadyPriorities ) ) )</span><br></code></pre></td></tr></table></figure><p>这里不带大家分析代码了，直接说过程和结论。</p><ul><li>每个任务在创建时都会根据自己的优先级将一个变量对应的那一位（比如自己的优先级为5，就会把一个32位变量的第5位置1，其他位不变）置1，这个变量是个全局变量。</li><li><code>__clz</code>指令可以计算出某个32位变量&#x3D;&#x3D;前导0&#x3D;&#x3D;的个数，拿31减去这个数，（比如当前最高优先级任务时20，那么之前的全局变量前导0个数就是11，31-11就是20）就可以得到当前就绪态链表最高优先级是位于哪个优先级链表中。（FreeRTOS每个优先级都会对应一个链表）</li><li>找到位于哪个链表之后，就可以直接去该链表中取出该任务的TCB，更新至<code>pxCurrentTCB</code>。</li></ul><p>当然还有另一种情况，如果我配置FreeRTOS可支持最大优先级超过32怎么办？比如设置成100，如果一个任务优先级为40，这个时候自然是不能使用这种方法了，因为<code>__clz</code>指令没办法获取64位变量前导零个数。这个时候就只能使用传统方法了，一个个链表找，从高优先级开始遍历，直至链表不为空。<br><img src="/img/freertos%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%88%86%E6%9E%90/32.jpeg" alt=" "></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目1：基于IMX6ULL开发板的综合测试工具设计</title>
    <link href="/2024/08/30/%E5%9F%BA%E4%BA%8Eimxu6ll%E7%9A%84%E7%BB%BC%E5%90%88%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/2024/08/30/%E5%9F%BA%E4%BA%8Eimxu6ll%E7%9A%84%E7%BB%BC%E5%90%88%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="展示视频"><a href="#展示视频" class="headerlink" title="展示视频"></a>展示视频</h1><video src='/video/v2.mp4' type='video/mp4' controls='controls'  width='100%' height='100%'></video><h1 id="第一章：环境搭建"><a href="#第一章：环境搭建" class="headerlink" title="第一章：环境搭建"></a>第一章：环境搭建</h1><!-- ![](/img/imx6ull.png) 在文章内容中插入图片方法 --><!-- <font color="#DCCD79">cd</font> ~/ --><h2 id="1-下载BSP和交叉编译工具链"><a href="#1-下载BSP和交叉编译工具链" class="headerlink" title="1.下载BSP和交叉编译工具链"></a>1.下载BSP和交叉编译工具链</h2><!-- <font color="#DCCD79">创建项目目录</font> --><p>创建项目目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/<br><span class="hljs-built_in">mkdir</span> imx6ull<br><span class="hljs-built_in">cd</span> ./imx6ull/<br></code></pre></td></tr></table></figure><p>设置git，如果未安装git,可以通过 sudo apt install git 来安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.email <span class="hljs-string">&quot;zhou@qq.com&quot;</span><br>git config --global user.name <span class="hljs-string">&quot;zhou&quot;</span><br></code></pre></td></tr></table></figure><p>git下载交叉编译工具链和BSP(出现错误一般是网络问题，检查网络多试几次)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://e.coding.net/codebug8/repo.git<br><span class="hljs-built_in">mkdir</span> -p 100ask_imx6ull-sdk &amp;&amp; <span class="hljs-built_in">cd</span> 100ask_imx6ull-sdk<br><br>../repo/repo init -u https://gitee.com/weidongshan/manifests.git -b linux-sdk -m imx6ull/100ask_imx6ull_linux4.9.88_release.xml --no-repo-verify<br><br>../repo/repo <span class="hljs-built_in">sync</span> -j8<br></code></pre></td></tr></table></figure><p>上述命令执行完毕的时候,ls一下，应该是这些文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">book@100ask:~/imx6ull/100ask_imx6ull-sdk$ <span class="hljs-built_in">ls</span><br>Buildroot_2020.02.x  Busybox_1.30.0  DevelopmentEnvConf  Linux-4.9.88  NoosProgramProject  ToolChain  Uboot-2017.03  Uboot-2018.03<br></code></pre></td></tr></table></figure><p>编译构建本项目需要借助cmake工具来自动生成Makefile文件来make整个工程<br>使用apt安装的cmake版本比较旧，这里演示如何手工编译安装新版的cmake<br>需要自己手动到官网去下载一个较新的cmake源码压缩包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/imx6ull<br><span class="hljs-built_in">mkdir</span> lib<br><span class="hljs-built_in">cd</span> ./lib<br><span class="hljs-comment"># 解压源码</span><br>tar -zxf cmake-3.30.2.tar.gz<br><span class="hljs-built_in">cd</span> ./cmake-3.30.2/<br><br><span class="hljs-comment"># 安装依赖库</span><br><span class="hljs-built_in">sudo</span> apt install openssl       <br><span class="hljs-built_in">sudo</span> apt install libssl-dev<br><span class="hljs-comment"># 配置源码，生成Makefile</span><br>./configure --prefix=$(<span class="hljs-built_in">pwd</span>)/tmp <br><span class="hljs-comment"># 编译</span><br>make -j8<br><span class="hljs-comment"># 安装</span><br>make install <br><span class="hljs-comment"># 创建软链接</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s $(<span class="hljs-built_in">pwd</span>)/tmp/bin/cmake /usr/bin/cmake <br><span class="hljs-comment"># 如果已经有旧版本的cmake了就需要先删除之前的软连接再重新创建新的软链接</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> /usr/bin/cmake<br></code></pre></td></tr></table></figure><h2 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi ~/.bashrc<br></code></pre></td></tr></table></figure><p>键盘切换大写，按两下G，跳转到文件结尾，将以下内容复制到文件尾部，按小写i插入数据<br>粘贴完成之后按两下ESC，输入:wq保存退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> ARCH=arm<br><span class="hljs-built_in">export</span> CROSS_COMPILE=arm-buildroot-linux-gnueabihfexport- <br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/home/book/imx6ull/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin<br></code></pre></td></tr></table></figure><p>修改完之后执行以下命令使其生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><h2 id="3-搭建源码编译环境"><a href="#3-搭建源码编译环境" class="headerlink" title="3.搭建源码编译环境"></a>3.搭建源码编译环境</h2><p>建一个放置源码的目录，后续项目的源码放在这里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/imx6ull<br><span class="hljs-built_in">mkdir</span> xf_project<br><span class="hljs-built_in">cd</span> ./xf_project<br></code></pre></td></tr></table></figure><h2 id="附加-CMake文件内容补充"><a href="#附加-CMake文件内容补充" class="headerlink" title="(附加)CMake文件内容补充"></a>(附加)CMake文件内容补充</h2><p>CMakeLists.txt的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake_minimum_required(VERSION 3.12)<br>project(xf_project)<br><br><span class="hljs-built_in">set</span>(CMAKE_C_COMPILER <span class="hljs-string">&quot;/home/book/imx6ull/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/arm-buildroot-linux-gnueabihf-gcc&quot;</span> CACHE STRING <span class="hljs-string">&quot;Updated variable&quot;</span> FORCE)<br><br>SET(GCC_USER_LINK_FLAGS    <span class="hljs-string">&quot;-lm&quot;</span>) <span class="hljs-comment"># 自己用到的库链接</span><br><br>add_executable(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> <span class="hljs-string">&quot;sys/main.c&quot;</span>)<br>target_link_libraries(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="hljs-variable">$&#123;GCC_USER_LINK_FLAGS&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="4-编译项目的第一个程序"><a href="#4-编译项目的第一个程序" class="headerlink" title="4.编译项目的第一个程序"></a>4.编译项目的第一个程序</h2><p>接下来我们在自己的PC机上编写代码，然后传到ubuntu进行交叉编译<br>编写好CMakeLists.txt之后，按如下步骤进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入项目工程目录</span><br><span class="hljs-built_in">cd</span> ~/imx6ull/xf_project <br><span class="hljs-comment"># 以后在此项目进行编译，可执行文件也在这里生成</span><br><span class="hljs-built_in">mkdir</span> build             <br><span class="hljs-built_in">cd</span> ./build<br><span class="hljs-comment"># 通过cmake生成Makefile</span><br>cmake ..          <br><span class="hljs-comment"># 编译      </span><br>make -j8                <br></code></pre></td></tr></table></figure><h2 id="5-硬件"><a href="#5-硬件" class="headerlink" title="5.硬件"></a>5.硬件</h2><p><img src="/img/2.jpg"><br>开发项目的硬件资源有：imx6ull开发板，IO拓展板，超声波模块，S90舵机模块，AT24C02模块，DHT11模块，HS0038红外遥控器，USB免驱摄像头</p><h1 id="第二章：UI界面设计"><a href="#第二章：UI界面设计" class="headerlink" title="第二章：UI界面设计"></a>第二章：UI界面设计</h1><h2 id="1-移植并配置lvgl"><a href="#1-移植并配置lvgl" class="headerlink" title="1.移植并配置lvgl"></a>1.移植并配置lvgl</h2><p>克隆lvgl库和lvgl_drivers库，这两个库均选择8.3版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b v8.3.0 https://github.com/lvgl/lvgl.git<br>git <span class="hljs-built_in">clone</span> -b v8.3.0 https://github.com/lvgl/lv_drivers.git<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将lvgl的配置文件lv_conf_template.h移动到ui目录，并重命名为lv_conf.h</span><br>文件开头： <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> 改为 <span class="hljs-keyword">if</span> <span class="hljs-number">1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_MEM_SIZE (1024U * 1024U)</span><br><br><span class="hljs-comment">// 开启帧率显示和内存监控</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_PERF_MONITOR 1 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_MEM_MONITOR 1</span><br><br><span class="hljs-comment">// 将lv_drivers的配置文件lv_drv_conf_template.h移动到ui目录，并重命名为lv_drv_conf.h</span><br>文件开头： <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> 改为 <span class="hljs-keyword">if</span> <span class="hljs-number">1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_FBDEV 1</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> FBDEV_PATH          <span class="hljs-string">&quot;/dev/fb0&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_EVDEV 1</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> EVDEV_NAME   <span class="hljs-string">&quot;/dev/input/event1&quot;</span></span><br><br><span class="hljs-comment">// 提供Linux下的心跳接口</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_TICK_CUSTOM 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LV_TICK_CUSTOM</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_TICK_CUSTOM_INCLUDE <span class="hljs-string">&lt;stdint.h&gt;</span>         <span class="hljs-comment">/*Header for the system time function*/</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_TICK_CUSTOM_SYS_TIME_EXPR (custom_tick_get())    <span class="hljs-comment">/*Expression evaluating to current system time in ms*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>   <span class="hljs-comment">/*LV_TICK_CUSTOM*/</span></span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 挂载命令</span><br>mount -t nfs -o nolock,vers=3 192.168.5.11:/home/book/nfs_rootfs /mnt<br></code></pre></td></tr></table></figure><p>关闭开发板自带GUI的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看系统自启动脚本</span><br><span class="hljs-built_in">ls</span> /etc/init.d/S*<br><br><span class="hljs-comment"># 内容如下,应该会有S99myirhmi2这个文件，可能会有S05lvgl这个文件</span><br>[root@100ask:/mnt/imx6ull]# <span class="hljs-built_in">ls</span> /etc/init.d/S*<br>/etc/init.d/S01syslogd  /etc/init.d/S09modload  /etc/init.d/S40network          /etc/init.d/S50mosquitto   /etc/init.d/S80dnsmasq<br>/etc/init.d/S02klogd    /etc/init.d/S10udev     /etc/init.d/S44modem-manager    /etc/init.d/S50pulseaudio  /etc/init.d/S98swupdate<br>/etc/init.d/S02sysctl   /etc/init.d/S20urandom  /etc/init.d/S45network-manager  /etc/init.d/S50sshd        /etc/init.d/S99myirhmi2<br>/etc/init.d/S05lvgl     /etc/init.d/S30dbus     /etc/init.d/S49ntp              /etc/init.d/S50telnet<br><br><span class="hljs-comment"># 使用mv将他们移到根目录，然后重启开发板即可</span><br><span class="hljs-built_in">mv</span> /etc/init.d/S05lvgl / <span class="hljs-comment"># (如果有)</span><br><span class="hljs-built_in">mv</span> /etc/init.d/S99myirhmi2 / <span class="hljs-comment">#(肯定有)</span><br>reboot<br></code></pre></td></tr></table></figure><h2 id="2-页面管理器设计"><a href="#2-页面管理器设计" class="headerlink" title="2.页面管理器设计"></a>2.页面管理器设计</h2><h2 id="3-主界面设计"><a href="#3-主界面设计" class="headerlink" title="3.主界面设计"></a>3.主界面设计</h2><p>加载图片背景</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 图片转换工具网址</span><br>https://lvgl.io/tools/imageconverter<br></code></pre></td></tr></table></figure><p>交叉编译freetype</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置，生成Makefile</span><br>./configure --host=arm-buildroot-linux-gnueabihf --prefix=<span class="hljs-variable">$PWD</span>/tmp --with-harfbuzz=no<br><span class="hljs-comment"># 编译</span><br>make -j12<br><span class="hljs-comment"># 安装</span><br>make install<br><br><span class="hljs-comment"># 拷贝库文件和头文件到交叉编译工具链的目录下</span><br><span class="hljs-built_in">cp</span> -drf <span class="hljs-variable">$PWD</span>/tmp/lib/* /home/book/imx6ull/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/lib/<br><br><span class="hljs-built_in">cp</span> -drf <span class="hljs-variable">$PWD</span>/tmp/include/* /home/book/imx6ull/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/include/<br></code></pre></td></tr></table></figure><p>制作图标按键</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 自定义图标库网站</span><br>https://fontawesome.com/search?o=r&amp;s=solid&amp;f=classic<br><br><span class="hljs-comment"># 字体转化网站</span><br>https://lvgl.io/tools/fontconverter<br><br><span class="hljs-comment"># unicode 转换为 utf-8 的工具</span><br>https://www.cogsci.ed.ac.uk/~richard/utf-8.cgi<br></code></pre></td></tr></table></figure><h1 id="第三章：功能模块设计"><a href="#第三章：功能模块设计" class="headerlink" title="第三章：功能模块设计"></a>第三章：功能模块设计</h1><h2 id="1-USB摄像头编程及其页面设计"><a href="#1-USB摄像头编程及其页面设计" class="headerlink" title="1.USB摄像头编程及其页面设计"></a>1.USB摄像头编程及其页面设计</h2><h2 id="2-简易相册系统的设计"><a href="#2-简易相册系统的设计" class="headerlink" title="2.简易相册系统的设计"></a>2.简易相册系统的设计</h2><p>修改lv_conf.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 启动SJPG解码器</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_SJPG 1</span><br><br><span class="hljs-comment">// 启用文件系统</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_USE_FS_STDIO 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LV_USE_FS_STDIO</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_LETTER <span class="hljs-string">&#x27;S&#x27;</span>     <span class="hljs-comment">/*Set an upper cased letter on which the drive will accessible (e.g. &#x27;A&#x27;)*/</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_PATH <span class="hljs-string">&quot;&quot;</span>         <span class="hljs-comment">/*Set the working directory. File/directory paths will be appended to it.*/</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LV_FS_STDIO_CACHE_SIZE 0    <span class="hljs-comment">/*&gt;0 to cache this number of bytes in lv_fs_read()*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><h2 id="3-超声波模块"><a href="#3-超声波模块" class="headerlink" title="3.超声波模块"></a>3.超声波模块</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 去内核目录编译内核</span><br><span class="hljs-built_in">cd</span> /home/book/imx6ull/100ask_imx6ull-sdk/Linux-4.9.88<br>make mrproper<br>make 100ask_imx6ull_defconfig<br>make zImage -j8<br>make dtbs<br><br><span class="hljs-comment"># 绝对路径编译内核和设备树</span><br><span class="hljs-comment"># 编译内核</span><br>make zImage -j12 -C /home/book/imx6ull/100ask_imx6ull-sdk/Linux-4.9.88/<br><br><span class="hljs-comment"># 编译设备树</span><br>make dtbs -j12 -C /home/book/imx6ull/100ask_imx6ull-sdk/Linux-4.9.88/<br><br><span class="hljs-comment"># 设备树文件决定路径</span><br><span class="hljs-built_in">cp</span> /home/book/imx6ull/100ask_imx6ull-sdk/Linux-4.9.88/arch/arm/boot/dts/100ask_imx6ull-14x14.dtb ~/nfs_rootfs/imx6ull/<br><br><span class="hljs-comment"># 打开内核打印信息</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;7 4 1 7&quot;</span> &gt; /proc/sys/kernel/printk<br></code></pre></td></tr></table></figure><h2 id="4-AT24C02模块"><a href="#4-AT24C02模块" class="headerlink" title="4.AT24C02模块"></a>4.AT24C02模块</h2><p>IIC测试命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">i2cdetect -y 0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记1：C语言指针和通用双向循环链表学习记录</title>
    <link href="/2024/08/30/%E7%AC%94%E8%AE%B01%EF%BC%9AC%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8C%87%E9%92%88%E5%92%8C%E9%80%9A%E7%94%A8%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/30/%E7%AC%94%E8%AE%B01%EF%BC%9AC%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8C%87%E9%92%88%E5%92%8C%E9%80%9A%E7%94%A8%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本节是笔记1：C语言的<strong>指针</strong>和<strong>通用双向循环链表</strong>学习记录。</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><ul><li><strong>野指针是指指向不可用内存的指针</strong>。当指针被创建时，指针不可能自动指向 NULL，这时默认值是随机的，此时指针成为野指针。 </li><li><strong>当指针被 free 或 delete 释放掉时，如果没有将指针指向 NULL</strong>，就会产生野指针，因为释放掉的是指针指向的内存，没有将指针本身释放掉。造成野指针的原因也可能是指针操作超越了变量的作用范围。比如数组越界，避免野指针的方法即使使用完之后释放内存，并将指针赋 NULL。</li></ul><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><ul><li>空指针是指没有指向任何一个存储单元的指针。</li></ul><h1 id="通用双向循环链表"><a href="#通用双向循环链表" class="headerlink" title="通用双向循环链表"></a>通用双向循环链表</h1><p><code> 通用双向循环链表可以包含单链表、通用链表、双向链表、循环链表的全部知识，所以只记录学习通用双向循环链表即可。</code></p><h2 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h2><ul><li>指链表中结点包含数据域和指针域，而通用链表的指针域通常用通用的node指针来表示，与该链表本身类型关系不大，只需要包含通用指针域即可。如：(node为通用指针域)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//学生结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">float</span> score;                    <br>    NODE node;      <span class="hljs-comment">//通用指针域类型的变量</span><br>&#125;STU,*PSTU;<br></code></pre></td></tr></table></figure><h2 id="双向性"><a href="#双向性" class="headerlink" title="双向性"></a>双向性</h2><ul><li>指针域包含<strong>前向指针pre</strong>和<strong>后向指针next</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//**************指针域************//</span><br><span class="hljs-comment">//该结构体是专门的指针域，包含在每个节点之中</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pre</span>;</span>              <span class="hljs-comment">//前向指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">next</span>;</span>             <span class="hljs-comment">//后向指针</span><br>&#125;NODE,*PNODE;<br></code></pre></td></tr></table></figure></li></ul><h2 id="循环性"><a href="#循环性" class="headerlink" title="循环性"></a>循环性</h2><ul><li><strong>链表尾部结点的next需要指向链表头</strong>，而非NULL，形成一个循环，后续初始化链表会有代码体现。</li></ul><h2 id="新建和初始化链表"><a href="#新建和初始化链表" class="headerlink" title="新建和初始化链表"></a>新建和初始化链表</h2><ul><li>初始化链表就是构造链表头结构体，分配内存。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//******链表********//</span><br><span class="hljs-comment">/* 构造链表头结构体 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span>&#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    NODE head;<br>&#125;LIST,*PLIST;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">PLIST stu_list;<span class="hljs-comment">//新建链表</span><br></code></pre></td></tr></table></figure><p><code> 可以在main函数中直接新建链表让编译器自动为我们分配内存</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 新建一个链表头部</span><br><span class="hljs-comment">* @List         ：已分配好内存的链表</span><br><span class="hljs-comment">* Return        ：无</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">NewListInit</span><span class="hljs-params">(PLIST List)</span><br>&#123;<br>    List-&gt;head.next    = &amp;List-&gt;head;  <span class="hljs-comment">//头部next属性设置为自己</span><br>    List-&gt;head.pre     = &amp;List-&gt;head;  <span class="hljs-comment">//头部pre属性设置为自己</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code> 在这里我们可以发现，在建立循环链表的时候使需要把pre和next属性都指向自己的地址，形成循环。</code></p><h2 id="尾插法插入结点"><a href="#尾插法插入结点" class="headerlink" title="尾插法插入结点"></a>尾插法插入结点</h2><ul><li>获取链表尾部，此时链表里面只有头结点，所以头结点作为我们的尾部</li><li>将被添加结点的next属性指向尾部结点的next属性</li><li>将尾部结点的next属性指向被添加结点地址</li><li>将被添加结点的pre属性指向尾部结点</li><li>将此时被添加结点的next属性指向的结点的pre属性指向被添加结点。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 添加一个节点至链表尾部</span><br><span class="hljs-comment">* @pList        ：需要添加节点的链表指针</span><br><span class="hljs-comment">* @new_node     ：被添加的节点指针</span><br><span class="hljs-comment">* Return        ：无</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">AddItemToList</span><span class="hljs-params">(PLIST pList, PNODE new_node)</span><br>&#123;<br>PNODE last = pList-&gt;head.pre;  <span class="hljs-comment">//找到链表尾部节点</span><br><br>new_node-&gt;next  = last-&gt;next; <span class="hljs-comment">//设置新添加节点next属性</span><br>last-&gt;next      = new_node;   <span class="hljs-comment">//设置尾部（当前）节点next属性</span><br>new_node-&gt;pre   = last;       <span class="hljs-comment">//设置新添加节点pre属性</span><br>pList-&gt;head.pre = new_node;   <span class="hljs-comment">//设置新添加节点的next节点pre属性</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表中间插入结点"><a href="#链表中间插入结点" class="headerlink" title="链表中间插入结点"></a>链表中间插入结点</h2><p><code> 与尾插法的方法一致，只是这里知道被插入结点是位于哪个结点后面，就不需要获取尾部结点了。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 插入一个节点至目标节点后面</span><br><span class="hljs-comment">* @Target       ：目标节点指针</span><br><span class="hljs-comment">* @new_node     ：被添加的节点指针</span><br><span class="hljs-comment">* Return        ：无</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">AddItemAfter</span><span class="hljs-params">(PNODE Target, PNODE new_node)</span><br>&#123;<br>    new_node-&gt;next      = Target-&gt;next; <span class="hljs-comment">//设置新添加节点next属性</span><br>    Target-&gt;next        = new_node;     <span class="hljs-comment">//设置目标节点next属性</span><br>    new_node-&gt;next-&gt;pre = new_node;     <span class="hljs-comment">//设置新添加节点的next节点pre属性</span><br>    new_node-&gt;pre       = Target;       <span class="hljs-comment">//设置新添加节节点pre属性</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h2><ul><li>被删除结点左侧结点next属性指向右侧结点</li><li>被删除结点右侧结点pre属性指向左侧结点<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 删除一个节点</span><br><span class="hljs-comment">* @del_node     ：被删除的节点指针</span><br><span class="hljs-comment">* Return        ：无</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DelItemFromList</span><span class="hljs-params">(PNODE del_node)</span><br>&#123;<br>    del_node-&gt;next-&gt;pre     = del_node-&gt;pre;<br>    del_node-&gt;pre-&gt;next     = del_node-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="反推数据域"><a href="#反推数据域" class="headerlink" title="&#x3D;&#x3D;反推数据域&#x3D;&#x3D;"></a>&#x3D;&#x3D;反推数据域&#x3D;&#x3D;</h2><p>根据指针域反推数据域是&#x3D;&#x3D;通用链表&#x3D;&#x3D;的核心知识，通用链表只通过node指针域进行连接，每个不同类型的链表都有自己的数据域格式，我们需要通过node反推出数据域的地址才能访问到里面的变量</p><p>学生链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//学生结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">float</span> score;                    <br>    NODE node;      <span class="hljs-comment">//通用指针域类型的变量</span><br>&#125;STU,*PSTU;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(<span class="hljs-keyword">struct</span> student *)((<span class="hljs-type">char</span> *)p - (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)&amp;((<span class="hljs-keyword">struct</span> student *)<span class="hljs-number">0</span>)-&gt;node)<br></code></pre></td></tr></table></figure><ul><li>我们来分析这行代码，首先是最终值，它是一个<code> (struct student *)</code>指针,我们的目的就是获取这样一个指针，使他可以访问到<code>student</code>学生结构体的所有信息，如<code>num、name</code>。</li><li>我们所拥有的是<code>node</code>结点的地址，因为这可以从链表中获取到。</li><li>这行代码中的<code>p</code>就是我们从链表中获取的<code>node</code>结点地址</li><li>内存中结构体地址的递增的，所以我们只要获取到<code>student</code>结构体首地址到<code>node</code>属性的地址处递增了多少字节，然后我们再用<code>p</code>减去递增的字节数就可以得到<code>student</code>的首地址了。</li><li><code>(struct student *)0)-&gt;node</code>这行代码是利用0地址下使用<code>struct student *</code>去访问<code>node</code>属性，为什么是0地址，因为我们把这个指针设置成0地址之后此时<code>node</code>属性的地址就正好是<code>student </code>结构体中储存<code>node</code>属性递增的字节数了。</li><li><code>(unsigned int)&amp;((struct student *)0)-&gt;node</code>可看到中间有个取址符号，此时它的地址就是递增字节数，我们把他强转成<code>(unsigned int)</code>告诉编译器进行普通的指针加减运算。</li><li><code>(char *)p</code>这里要强转<code>char *</code>告诉编译器进行普通指针加减运算。</li><li><code>(struct student *)</code>最后强转成我们想要的<code>student </code>首地址，接下来就可以通过这个指针访问里边的变量了。</li></ul><h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p> 使用冒泡排序法，做两层排序，四步走</p><ul><li><p>两个结点，一个比较结点，一个被比较结点。比较结点是外循环，被比较结点内循环</p></li><li><p>外循环的比较结点固定，然后内循环开始递增，逐个比较。</p></li><li><p>比较函数后面讲，先关注排序逻辑，我们从小到大排序，比较函数返回小于时不交换，比较函数返回大于时进行交换</p></li><li><p>&#x3D;&#x3D;结点交换的实现&#x3D;&#x3D;：</p><ul><li>记录下两个结点的前一个结点地址</li><li>将两个结点都删除</li><li>结点2插入结点1前一个结点之后，结点1插入结点2前一个结点之后</li><li><code>还需要判断两个结点相邻的情况，相邻情况下需要特殊处理，删除结点之后直接将结点2插入结点1之后即可</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SortList</span><span class="hljs-params">(PLIST pList)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pre1</span> =</span> &amp;pList-&gt;head;<span class="hljs-comment">//从链表头开始</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pre2</span>;</span><span class="hljs-comment">//这个是用来记录上一次比较时被比较数的pre指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">cur</span> =</span> pre1-&gt;next;<span class="hljs-comment">//开始比较的第一个结点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//类比数组的索引，冒泡排序的i，j</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">tmp</span>;</span><span class="hljs-comment">//用于交换的中间结点</span><br><br><span class="hljs-keyword">while</span> (cur != &amp;pList-&gt;head) <span class="hljs-comment">//当前比较的目标不是链表尾部</span><br>&#123;<br>pre2 = cur;<br>next = cur-&gt;next;<br><span class="hljs-keyword">while</span> (next != &amp;pList-&gt;head)    <span class="hljs-comment">//冒泡排序第二层</span><br>&#123;<br><span class="hljs-keyword">if</span> (CmpStudentNum(cur, next) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">/* 交换节点 */</span><br><span class="hljs-comment">/* 1. del cur */</span><br>DelItemFromList(cur);<br><span class="hljs-comment">/* 2. del next */</span><br>DelItemFromList(next);<br><span class="hljs-comment">/* 3. 在pre1之后插入next */</span><br>AddItemAfter(pre1, next);   <span class="hljs-comment">//pre1记录的是比较数的pre指针</span><br><span class="hljs-comment">/* 4. 在pre2之后插入cur */</span><br><span class="hljs-keyword">if</span> (pre2 == cur)            <span class="hljs-comment">//如果被比较数pre指针等于当前节点的指针,说明两个节点相邻</span><br>AddItemAfter(next, cur);<br><span class="hljs-keyword">else</span><br>AddItemAfter(pre2, cur);<br><br><span class="hljs-comment">/* 5. cur/next指针互换 */</span><br>tmp = cur;<br>cur = next;<br>next = tmp;<br>&#125;<br><br>pre2 = next;            <span class="hljs-comment">//这个是用来记录上一次比较时被比较数的pre指针</span><br>next = next-&gt;next;      <span class="hljs-comment">//继续往前比较</span><br>&#125;<br><br>pre1 = cur;         <span class="hljs-comment">//这个是用来记录上一次比较时比较数的pre指针</span><br>cur = cur-&gt;next;    <span class="hljs-comment">//继续往前比较</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>比较函数</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> container_of(ptr, type, member) \</span><br><span class="hljs-meta">(type *)((char *)ptr - (unsigned int)&amp;((type *)0)-&gt;member)</span><br></code></pre></td></tr></table></figure><p>宏定义实现前面说的反推数据域操作，实现原理是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 比较两个学生的num属性</span><br><span class="hljs-comment">* @pre          ：目标节点1</span><br><span class="hljs-comment">* @next         ：目标节点2</span><br><span class="hljs-comment">* Return        ：大于时返回0， 小于时返回-1</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">CmpStudentNum</span><span class="hljs-params">(PNODE pre, PNODE next)</span><br>&#123;<br>PSTU p;<br>PSTU n;<br><br>p = container_of(pre, <span class="hljs-keyword">struct</span> student, node);<br>n = container_of(next, <span class="hljs-keyword">struct</span> student, node);<br><br><span class="hljs-keyword">if</span> (p-&gt;num &lt; n-&gt;num)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，反推出数据域之后比较他们的<code>num</code>参数，根据结果进行返回即可。</p><h1 id="完整工程代码"><a href="#完整工程代码" class="headerlink" title="完整工程代码"></a>完整工程代码</h1><p>完整工程代码如下，已经过验证，可以正常运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> container_of(ptr, type, member) \</span><br><span class="hljs-meta">(type *)((char *)ptr - (unsigned int)&amp;((type *)0)-&gt;member)</span><br><br><span class="hljs-comment">//**************指针域************//</span><br><span class="hljs-comment">//该结构体是专门的指针域，包含在每个节点之中</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pre</span>;</span>              <span class="hljs-comment">//前向指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">next</span>;</span>             <span class="hljs-comment">//后向指针</span><br>&#125;NODE,*PNODE;<br><br><span class="hljs-comment">//******链表********//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span>&#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    NODE head;<br>&#125;LIST,*PLIST;<br><br><span class="hljs-comment">//学生结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">float</span> score;                    <br>    NODE node;      <span class="hljs-comment">//通用指针域类型的变量</span><br>&#125;STU,*PSTU;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">teacher</span>              //教师</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">char</span> subj[<span class="hljs-number">20</span>];                  <br>    NODE node;                     <span class="hljs-comment">//同上</span><br>&#125;TEA,*PTEA;<br><br><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 新建一个链表头部</span><br><span class="hljs-comment">* @List         ：已分配好内存的链表</span><br><span class="hljs-comment">* Return        ：无</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">NewListInit</span><span class="hljs-params">(PLIST List)</span><br>&#123;<br>    List-&gt;head.next    = &amp;List-&gt;head;  <span class="hljs-comment">//头部next属性设置为自己</span><br>    List-&gt;head.pre     = &amp;List-&gt;head;  <span class="hljs-comment">//头部pre属性设置为自己</span><br>&#125;<br><br><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 添加一个节点至链表尾部</span><br><span class="hljs-comment">* @pList        ：需要添加节点的链表指针</span><br><span class="hljs-comment">* @new_node     ：被添加的节点指针</span><br><span class="hljs-comment">* Return        ：无</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">AddItemToList</span><span class="hljs-params">(PLIST pList, PNODE new_node)</span><br>&#123;<br>PNODE last = pList-&gt;head.pre;  <span class="hljs-comment">//找到链表尾部节点</span><br><br>new_node-&gt;next  = last-&gt;next; <span class="hljs-comment">//设置新添加节点next属性</span><br>last-&gt;next      = new_node;   <span class="hljs-comment">//设置尾部（当前）节点next属性</span><br>new_node-&gt;pre   = last;       <span class="hljs-comment">//设置新添加节点pre属性</span><br>pList-&gt;head.pre = new_node;   <span class="hljs-comment">//设置新添加节点的next节点pre属性</span><br>&#125;<br><br><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 插入一个节点至目标节点后面</span><br><span class="hljs-comment">* @Target       ：目标节点指针</span><br><span class="hljs-comment">* @new_node     ：被添加的节点指针</span><br><span class="hljs-comment">* Return        ：无</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">AddItemAfter</span><span class="hljs-params">(PNODE Target, PNODE new_node)</span><br>&#123;<br>    new_node-&gt;next      = Target-&gt;next; <span class="hljs-comment">//设置新添加节点next属性</span><br>    Target-&gt;next        = new_node;     <span class="hljs-comment">//设置目标节点next属性</span><br>    new_node-&gt;next-&gt;pre = new_node;     <span class="hljs-comment">//设置新添加节点的next节点pre属性</span><br>    new_node-&gt;pre       = Target;       <span class="hljs-comment">//设置新添加节节点pre属性</span><br>&#125;<br><br><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 删除一个节点</span><br><span class="hljs-comment">* @del_node     ：被删除的节点指针</span><br><span class="hljs-comment">* Return        ：无</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DelItemFromList</span><span class="hljs-params">(PNODE del_node)</span><br>&#123;<br>    del_node-&gt;next-&gt;pre     = del_node-&gt;pre;<br>    del_node-&gt;pre-&gt;next     = del_node-&gt;next;<br>&#125;<br><br><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 链表排序</span><br><span class="hljs-comment">* @pList        ：目标链表</span><br><span class="hljs-comment">* Return        ：无</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">CmpStudentNum</span><span class="hljs-params">(PNODE pre, PNODE next)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SortList</span><span class="hljs-params">(PLIST pList)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pre1</span> =</span> &amp;pList-&gt;head;<span class="hljs-comment">//从链表头开始</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">pre2</span>;</span><span class="hljs-comment">//这个是用来记录上一次比较时被比较数的pre指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">cur</span> =</span> pre1-&gt;next;<span class="hljs-comment">//开始比较的第一个结点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//类比数组的索引，冒泡排序的i，j</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">tmp</span>;</span><span class="hljs-comment">//用于交换的中间结点</span><br><br><span class="hljs-keyword">while</span> (cur != &amp;pList-&gt;head) <span class="hljs-comment">//当前比较的目标不是链表尾部</span><br>&#123;<br>pre2 = cur;<br>next = cur-&gt;next;<br><span class="hljs-keyword">while</span> (next != &amp;pList-&gt;head)    <span class="hljs-comment">//冒泡排序第二层</span><br>&#123;<br><span class="hljs-keyword">if</span> (CmpStudentNum(cur, next) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">/* 交换节点 */</span><br><span class="hljs-comment">/* 1. del cur */</span><br>DelItemFromList(cur);<br><span class="hljs-comment">/* 2. del next */</span><br>DelItemFromList(next);<br><span class="hljs-comment">/* 3. 在pre1之后插入next */</span><br>AddItemAfter(pre1, next);   <span class="hljs-comment">//pre1记录的是比较数的pre指针</span><br><span class="hljs-comment">/* 4. 在pre2之后插入cur */</span><br><span class="hljs-keyword">if</span> (pre2 == cur)            <span class="hljs-comment">//如果被比较数pre指针等于当前节点的指针,说明两个节点相邻</span><br>AddItemAfter(next, cur);<br><span class="hljs-keyword">else</span><br>AddItemAfter(pre2, cur);<br><br><span class="hljs-comment">/* 5. cur/next指针互换 */</span><br>tmp = cur;<br>cur = next;<br>next = tmp;<br>&#125;<br><br>pre2 = next;            <span class="hljs-comment">//这个是用来记录上一次比较时被比较数的pre指针</span><br>next = next-&gt;next;      <span class="hljs-comment">//继续往前比较</span><br>&#125;<br><br>pre1 = cur;         <span class="hljs-comment">//这个是用来记录上一次比较时比较数的pre指针</span><br>cur = cur-&gt;next;    <span class="hljs-comment">//继续往前比较</span><br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 比较两个学生的num属性</span><br><span class="hljs-comment">* @pre          ：目标节点1</span><br><span class="hljs-comment">* @next         ：目标节点2</span><br><span class="hljs-comment">* Return        ：大于时返回0， 小于时返回-1</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">CmpStudentNum</span><span class="hljs-params">(PNODE pre, PNODE next)</span><br>&#123;<br>PSTU p;<br>PSTU n;<br><br>p = container_of(pre, <span class="hljs-keyword">struct</span> student, node);<br>n = container_of(next, <span class="hljs-keyword">struct</span> student, node);<br><br><span class="hljs-keyword">if</span> (p-&gt;num &lt; n-&gt;num)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 打印链表</span><br><span class="hljs-comment">* @pList        ：目标链表</span><br><span class="hljs-comment">* Return        ：无</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintList</span><span class="hljs-params">(PLIST pList)</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>PNODE node_1 = pList-&gt;head.next;      <span class="hljs-comment">//得到链表头部的next属性</span><br>PSTU p;<br><br><span class="hljs-keyword">while</span> (node_1 != &amp;pList-&gt;head)        <span class="hljs-comment">//如果头部的next不是头部，代表还没有到链表尾部</span><br>&#123;<br>p = container_of(node_1, <span class="hljs-keyword">struct</span> student, node);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;person %d: num is %d\r\n&quot;</span>, i++, p-&gt;num);<br><br><span class="hljs-comment">/* 后面还有人, 移动到下一个 */</span><br>node_1 = node_1-&gt;next;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    PLIST stu_list;<br>    PSTU stus1,stus2,stus3,stus4,stus5,stus6;<br><br>    stu_list = (PLIST)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LIST)); <span class="hljs-comment">//分配内存</span><br>    NewListInit(stu_list);                  <span class="hljs-comment">//初始化链表</span><br><br>    stus1 = (PSTU)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(STU)); <span class="hljs-comment">//分配内存</span><br>    stus2 = (PSTU)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(STU)); <span class="hljs-comment">//分配内存</span><br>    stus3 = (PSTU)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(STU)); <span class="hljs-comment">//分配内存</span><br>    stus4 = (PSTU)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(STU)); <span class="hljs-comment">//分配内存</span><br>    stus5 = (PSTU)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(STU)); <span class="hljs-comment">//分配内存</span><br>    stus6 = (PSTU)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(STU)); <span class="hljs-comment">//分配内存</span><br><br>    stus1-&gt;num = <span class="hljs-number">20</span>;<br>    stus2-&gt;num = <span class="hljs-number">40</span>;<br>    stus3-&gt;num = <span class="hljs-number">30</span>;<br>    stus4-&gt;num = <span class="hljs-number">10</span>;<br>    stus5-&gt;num = <span class="hljs-number">50</span>;<br>    stus6-&gt;num = <span class="hljs-number">100</span>;<br><br>    AddItemToList(stu_list, &amp;stus1-&gt;node);  <span class="hljs-comment">//添加进链表尾部，尾插法</span><br>    AddItemToList(stu_list, &amp;stus2-&gt;node);  <span class="hljs-comment">//添加进链表尾部，尾插法</span><br>    AddItemToList(stu_list, &amp;stus3-&gt;node);  <span class="hljs-comment">//添加进链表尾部，尾插法</span><br>    AddItemToList(stu_list, &amp;stus4-&gt;node);  <span class="hljs-comment">//添加进链表尾部，尾插法</span><br>    AddItemToList(stu_list, &amp;stus5-&gt;node);  <span class="hljs-comment">//添加进链表尾部，尾插法</span><br><br>    PrintList(stu_list);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n Del node3\r\n&quot;</span>);<br>    DelItemFromList(&amp;stus3-&gt;node);<br>    PrintList(stu_list);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n add node1-&gt;node6\r\n&quot;</span>);<br>    AddItemAfter(&amp;stus1-&gt;node, &amp;stus6-&gt;node);<br>    PrintList(stu_list);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n Sort List\r\n&quot;</span>);<br>    SortList(stu_list);<br>    PrintList(stu_list);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes!\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记2：C语言的内存管理，用户栈的代码实现</title>
    <link href="/2024/08/30/%E7%AC%94%E8%AE%B02%EF%BC%9AC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%8C%E7%94%A8%E6%88%B7%E6%A0%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/08/30/%E7%AC%94%E8%AE%B02%EF%BC%9AC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%8C%E7%94%A8%E6%88%B7%E6%A0%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本节是笔记2：C语言的内存管理，用户栈的代码实现学习记录。</p><h1 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h1><p>C语言中的内存分区从上往下依次是：</p><ul><li><strong>栈区</strong>：存放局部变量、函数传递的参数、函数返回值及返回地址、const定义的局部变量。</li><li><strong>堆区</strong>：一块可分配内存，堆区由程序员分配内存和释放</li><li><strong>.bss段</strong>：存放未初始化或初始值为0的全局变量，特点是<code>不占用可执行文件空间</code>，.bss段通常需要进行清零操作。</li><li><strong>.data段</strong>：存放有初始值的全局变量、静态变量，其中const修饰的变量存放在.rodata段。<code>.data段涉及代码重定位，.data的初始值需要被拷贝至运行地址才能正常访问，在C标准函数__main中实现拷贝。</code></li><li><strong>常量区</strong>：const修饰的全局变量或静态变量，STM32中会将其保存在FLASH中，也叫<code>.rodata</code>段。</li><li><strong>代码段</strong>：存放程序的代码，即被转化为机器码的二进制数据。</li><li><strong>空字节段</strong>：从0地址开始直到代码段的区域， 是没有用到的字节区域，<code>一般存放指向NULL的空指针</code>。</li></ul><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>一般使用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_t</span> *<span class="hljs-title">p</span> =</span> (<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span>));<br></code></pre></td></tr></table></figure><p>申请一块想要的内存大小并返回首地址，Linux中内部是通过<code>sbrk</code>函数向内核申请内存来实现的，其内部还需要实现查找内存块、各种内存块链表操作等，这里不细说。</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>一般使用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//记得释放内存</span><br></code></pre></td></tr></table></figure><p><code>free</code>只能释放<code>malloc</code>返回的指针，否则会报错，<code>free</code>内部操作较为复杂，除了将已申请的<code>malloc</code>内存块插入到空闲内存块链表以外，还要完成相邻内存块合并等操作来最大限度利用空间，最大程度减少内存碎片。<br>&#x3D;&#x3D;只<code>malloc</code>而不进行<code>free</code>将会导致内存泄漏，导致之前被申请的内存块处于空闲但不能被再次申请&#x3D;&#x3D;</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈操作通常由编译器自己完成，通常在程序需要调用函数跳转时进行栈的操作，栈操作有<code>push</code>入栈和<code>pop</code>出栈。可以通过编写简单的函数调用程序，然后观察其反汇编代码查看编译器入栈和出栈的过程。这里不细说，本节重点在下文。</p><h1 id="用户栈的代码实现"><a href="#用户栈的代码实现" class="headerlink" title="用户栈的代码实现"></a>用户栈的代码实现</h1><h2 id="用户栈分类"><a href="#用户栈分类" class="headerlink" title="用户栈分类"></a>用户栈分类</h2><ul><li><strong>数组栈</strong>：栈内存是数组，一块连续的内存，大小自定义指定，数组的索引作为栈顶指针。</li><li><strong>链表栈</strong>：栈内存需要动态分配，一个数据对应一个结点，大小视程序而定，不需要自己指定，以头结点的<code>node</code>属性作为索引。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_MAX_SIZE1*1024<span class="hljs-comment">//设置栈大小</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_STACK1<span class="hljs-comment">//指定使用数组栈</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_STACK2<span class="hljs-comment">//指定使用链表栈</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_TYPE ARRAY_STACK   <span class="hljs-comment">//指定使用哪种栈类型</span></span><br><br><span class="hljs-comment">//构建自定义栈结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_t</span>&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STACK_TYPE == ARRAY_STACK</span><br>    <span class="hljs-type">int</span> stack_data[STACK_MAX_SIZE]; <span class="hljs-comment">//栈内存</span><br>    <span class="hljs-type">int</span> stack_sp;                   <span class="hljs-comment">//栈顶指针</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> STACK_TYPE == LIST_STACK</span><br>    <span class="hljs-type">int</span> data;<span class="hljs-comment">//栈结点数据</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_t</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个结点</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;stacks;<br></code></pre></td></tr></table></figure><h2 id="新建栈和初始化栈"><a href="#新建栈和初始化栈" class="headerlink" title="新建栈和初始化栈"></a>新建栈和初始化栈</h2><ul><li><strong>数组栈</strong>：定义一个栈结构体，编译器自动分配内存，再把&#x3D;&#x3D;栈顶指针&#x3D;&#x3D;即数组索引值设置为<code>0</code>即可。</li><li><strong>链表栈</strong>：定义一个栈结构体，编译器自动分配内存，再把&#x3D;&#x3D;栈顶指针&#x3D;&#x3D;即栈链表头部<code>next</code>设置为<code>NULL</code>即可。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">StackUserInit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span> *pStack_User)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STACK_TYPE == ARRAY_STACK</span><br>pStack_User-&gt;stack_sp = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> STACK_TYPE == LIST_STACK</span><br>pStack_User-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Push实现"><a href="#Push实现" class="headerlink" title="Push实现"></a>Push实现</h2><ul><li><strong>数组栈Push</strong>：先填入数据，再栈顶指针偏移。</li><li><strong>链表栈Push</strong>：先申请一个新的数据结点的内存并将数据填入，再插入到栈链表头部结点<code>next</code>属性之后。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 入栈</span><br><span class="hljs-comment">* @pStack_User  : 目标栈的指针</span><br><span class="hljs-comment">* @data  : 入栈数据</span><br><span class="hljs-comment">* Return        : 0:入栈成功    </span><br><span class="hljs-comment">* -1：入栈失败，可能是栈满了</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span> *pStack_User, <span class="hljs-type">int</span> data)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STACK_TYPE == ARRAY_STACK</span><br><span class="hljs-comment">/* 如果栈还没满 */</span><br><span class="hljs-keyword">if</span>(pStack_User-&gt;stack_sp != STACK_MAX_SIZE)&#123;<br>pStack_User-&gt;stack_data[pStack_User-&gt;stack_sp] = data;<span class="hljs-comment">//数据入栈</span><br>pStack_User-&gt;stack_sp++;<span class="hljs-comment">//栈顶指针偏移</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">/* 栈已满 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> STACK_TYPE == LIST_STACK</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_t</span> *<span class="hljs-title">p</span> =</span> (<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span>));<br><span class="hljs-keyword">if</span>(p)&#123;<br><span class="hljs-comment">/* 先储存数据 */</span><br>p-&gt;data = data;<br><span class="hljs-comment">/* 再插入链表 */</span><br>p-&gt;next = pStack_User-&gt;next;<br>pStack_User-&gt;next = p;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">/* 内存申请失败，入栈失败 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Pop实现"><a href="#Pop实现" class="headerlink" title="Pop实现"></a>Pop实现</h2><ul><li><strong>数组栈Pop</strong>：先将栈顶指针偏移，再返回数据。</li><li><strong>链表栈Pop</strong>：先将当前栈顶指针<code>next</code>属性处数据储存，再删除该结点并释放内存，最后返回数据。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 出栈</span><br><span class="hljs-comment">* @pStack_User  : 目标栈的指针</span><br><span class="hljs-comment">* @data  : 数据存储指针</span><br><span class="hljs-comment">* Return        : 0:入栈成功    </span><br><span class="hljs-comment">* -1：入栈失败，可能是栈满了</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span> *pStack_User, <span class="hljs-type">int</span> *data)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STACK_TYPE == ARRAY_STACK</span><br><span class="hljs-comment">/* 如果栈不是空的 */</span><br><span class="hljs-keyword">if</span>(pStack_User-&gt;stack_sp != <span class="hljs-number">0</span>)&#123;<br>pStack_User-&gt;stack_sp--;<span class="hljs-comment">//栈顶指针偏移</span><br>*data = pStack_User-&gt;stack_data[pStack_User-&gt;stack_sp];<span class="hljs-comment">//数据出栈</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">/* 栈是空的 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> STACK_TYPE == LIST_STACK</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_t</span> *<span class="hljs-title">p</span> =</span> pStack_User-&gt;next;<span class="hljs-comment">//获得头结点后第一个栈结点指针</span><br><span class="hljs-comment">/* 如果栈不是空的 */</span><br><span class="hljs-keyword">if</span>(p)&#123;<br>pStack_User-&gt;next = p-&gt;next;<span class="hljs-comment">//删除该栈结点</span><br>*data = p-&gt;data;<span class="hljs-comment">//返回数据</span><br><span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//记得释放内存</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">/* 栈是空的 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="用户栈操作注意"><a href="#用户栈操作注意" class="headerlink" title="用户栈操作注意"></a>用户栈操作注意</h2><ul><li><code>Push</code>与<code>Pop</code>都需要判断栈满与栈空的情况，代码中均已体现。</li></ul><h1 id="完整工程代码"><a href="#完整工程代码" class="headerlink" title="完整工程代码"></a>完整工程代码</h1><ul><li>所有代码均已进行测试，在windows上可以正常运行。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_MAX_SIZE1*1024<span class="hljs-comment">//设置栈大小</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_STACK1<span class="hljs-comment">//指定使用数组栈</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_STACK2<span class="hljs-comment">//指定使用链表栈</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_TYPE ARRAY_STACK   <span class="hljs-comment">//指定使用哪种栈类型</span></span><br><br><span class="hljs-comment">//构建自定义栈结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_t</span>&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STACK_TYPE == ARRAY_STACK</span><br>    <span class="hljs-type">int</span> stack_data[STACK_MAX_SIZE]; <span class="hljs-comment">//栈内存</span><br>    <span class="hljs-type">int</span> stack_sp;                   <span class="hljs-comment">//栈顶指针</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> STACK_TYPE == LIST_STACK</span><br>    <span class="hljs-type">int</span> data;<span class="hljs-comment">//栈结点数据</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_t</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个结点</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;stacks;<br><br><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 入栈</span><br><span class="hljs-comment">* @pStack_User  : 目标栈的指针</span><br><span class="hljs-comment">* @data  : 入栈数据</span><br><span class="hljs-comment">* Return        : 0:入栈成功    </span><br><span class="hljs-comment">* -1：入栈失败，可能是栈满了</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span> *pStack_User, <span class="hljs-type">int</span> data)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STACK_TYPE == ARRAY_STACK</span><br><span class="hljs-comment">/* 如果栈还没满 */</span><br><span class="hljs-keyword">if</span>(pStack_User-&gt;stack_sp != STACK_MAX_SIZE)&#123;<br>pStack_User-&gt;stack_data[pStack_User-&gt;stack_sp] = data;<span class="hljs-comment">//数据入栈</span><br>pStack_User-&gt;stack_sp++;<span class="hljs-comment">//栈顶指针偏移</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">/* 栈已满 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> STACK_TYPE == LIST_STACK</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_t</span> *<span class="hljs-title">p</span> =</span> (<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span>));<br><span class="hljs-keyword">if</span>(p)&#123;<br><span class="hljs-comment">/* 先储存数据 */</span><br>p-&gt;data = data;<br><span class="hljs-comment">/* 再插入链表 */</span><br>p-&gt;next = pStack_User-&gt;next;<br>pStack_User-&gt;next = p;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">/* 内存申请失败，入栈失败 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">* Description   : 出栈</span><br><span class="hljs-comment">* @pStack_User  : 目标栈的指针</span><br><span class="hljs-comment">* @data  : 数据存储指针</span><br><span class="hljs-comment">* Return        : 0:入栈成功    </span><br><span class="hljs-comment">* -1：入栈失败，可能是栈满了</span><br><span class="hljs-comment">**********************************************************/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span> *pStack_User, <span class="hljs-type">int</span> *data)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STACK_TYPE == ARRAY_STACK</span><br><span class="hljs-comment">/* 如果栈不是空的 */</span><br><span class="hljs-keyword">if</span>(pStack_User-&gt;stack_sp != <span class="hljs-number">0</span>)&#123;<br>pStack_User-&gt;stack_sp--;<span class="hljs-comment">//栈顶指针偏移</span><br>*data = pStack_User-&gt;stack_data[pStack_User-&gt;stack_sp];<span class="hljs-comment">//数据出栈</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">/* 栈是空的 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> STACK_TYPE == LIST_STACK</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_t</span> *<span class="hljs-title">p</span> =</span> pStack_User-&gt;next;<span class="hljs-comment">//获得头结点后第一个栈结点指针</span><br><span class="hljs-comment">/* 如果栈不是空的 */</span><br><span class="hljs-keyword">if</span>(p)&#123;<br>pStack_User-&gt;next = p-&gt;next;<span class="hljs-comment">//删除该栈结点</span><br>*data = p-&gt;data;<span class="hljs-comment">//返回数据</span><br><span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//记得释放内存</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">/* 栈是空的 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StackUserInit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span> *pStack_User)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STACK_TYPE == ARRAY_STACK</span><br>pStack_User-&gt;stack_sp = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> STACK_TYPE == LIST_STACK</span><br>pStack_User-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintStack</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">stack_t</span> *pStack_User)</span><br>&#123;<br><span class="hljs-type">int</span> buf;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(Pop(pStack_User, &amp;buf) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack_User_Pop top%d: %d\r\n&quot;</span>,i++, buf);<br>&#125;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_t</span> <span class="hljs-title">Stack_User</span>;</span><br>StackUserInit(&amp;Stack_User);<br><br>Push(&amp;Stack_User, <span class="hljs-number">100</span>);<br>Push(&amp;Stack_User, <span class="hljs-number">200</span>);<br>Push(&amp;Stack_User, <span class="hljs-number">300</span>);<br>Push(&amp;Stack_User, <span class="hljs-number">400</span>);<br>Push(&amp;Stack_User, <span class="hljs-number">500</span>);<br><br>PrintStack(&amp;Stack_User);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;完成!\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
